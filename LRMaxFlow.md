방법 1) a번 정점에서 b번 정점으로 가는 하한 l, 상한 r인 간선이 있을 때, a번 정점에서 b번 정점으로 가는 유량 l, 비용 -1인 간선, 유량 r-l, 비용 0인 간선으로 만든 뒤 mincost-maxflow
방법 2) a번 정점에서 b번 정점으로 가는 하한 l, 상한 r인 간선이 있을 때, 새로운 source에서 b번 정점으로 가는 유량 l인 간선 추가, a번 정점에서 새로운 sink로 가는 유량 l인 간선 추가, a번 정점에서 b번 정점으로 가는 유량 r-l인 간선으로 만들고, 기존 sink에서 기존 source로 가는 유량 무한인 간선 추가 이후 최대 유량이 l의 합이 되는지 확인,
이후 원래 source,sink에 대해서 maxflow를 구함(이전에 구한건 하한만 결정할뿐, 답에 더하지 않는다.)


출처: http://blog.myungwoo.kr/111 [PS 이야기]

4) 부분 순서 집합의 최대 반사슬의 크기가 최소 Path Cover의 크기와 같은 이유 (Dilworth's theorem)
정의 3. 부분 순서 집합은 사이클이 없는 방향성 그래프로, 임의의 정점 i, j, k에 대해서 i에서 j로 가는 에지와, j에서 k로 가는 에지가 있으면, i에서 k로 가는 에지가 항상 존재하는 성질을 가진다. 
정의 4. 부분 순서 집합의 반사슬은, 정점의 부분집합으로, 부분집합의 임의의 정점 i, j에 대해, i -> j로도, j -> i로도 에지가 없는 집합을 뜻한다.
쉽게 설명하자면, DAG에 플로이드 돌리면 부분 순서 집합이다. 대전 리저널에도 나왔었고 (2012 K) 그렇게 낯선 개념은 아니다. 예시 문제를 들면 "DAG가 주어졌을 때, 서로 경로가 없는 최대 정점 집합을 출력하라" 같은 문제가 있겠다. 플로이드를 돌려서 부분 순서 집합으로 만들어 주고 반사슬을 구하면 된다. 
부분 순서 집합의 최대 반사슬은 최소 Path Cover라는 내용이 Dilworth's Theorem이다. Path Cover는 대충 이렇게 구할 수 있다. 이제 이것의 크기와 최대 반사슬의 크기가 같음을 보인다.

Theorem. 부분 순서 집합에서, 최소 Path Cover의 크기 == 최대 반사슬의 크기

출처: http://koosaga.com/133 [구사과]
